* PYTHON
	* Арифметические операции
		* • сложение (+) • вычитание (-) • умножение (*) • деление (/) • целочисленное деление (//) • возведение в степень (**) • взятие остатка от деления (%)
	* Операторы сравнения
		* • > • = • <= • !=
	* Логические операторы
		* AND OR NOT
	* Операторы проверки вхождения
		* IN NOT IN
	* Индексация и срезы
		* Левая граница - включена, правая - не включена
	* Синтактический сахар
		* List comprehension
			* Создать список, элементами которого являются квадраты целых чисел. Классический способ: squares = [] for x in range(10): squares.append(x**2)
				* squares = [x**2 for x in range(10)]
			* для циклов: for i in range(x+1): _for j in range(y+1): __for k in range(z+1): ___ lst.append([i,j,k])
				* lst = [[i,j,k] for i in range(x+1) for j in range(y+1) for k in range(z+1)]
			* Распаковываем элементы из списка Если вам нужно вытащить из последовательности определенные значения, можно присвоить переменную каждому элементу в этой последовательности: x, y = (15, 5)
			* с условием if: for i in lst: _if sum(i) !=3: __answer.append(i)
				* answer = [i for i in lst if sum(i) !=3]
	* Библиотеки для DS
		* pandas
			* [ссылка](https://drive.google.com/file/d/1smFepT748IxG-dK2BfS-oue3wOkIWwyq/view?usp=sharing)
		* numpy
			* [ссылка](https://drive.google.com/file/d/13DobNcfa6uXWG6KiN52adYdlStgyzelU/view?usp=sharing)
		* sklearn
		* matplotlib
		* seaborn
		* statsmodels
	* Переменная – это объект, которому дано имя.
		* Области видимости
			* Глобальная область видимости Глобальный контекстподразумевает, что переменная является глобальной, она определена вне любой из функций и доступна любой функци
			* Локальная область видимости В отличие от глобальных переменных локальная переменнаяопределяется внутри функции и доступна только из этой функции, то есть им
	* Условные конструкции
		* if elif else
	* Типы данных
		* Простые
			* integer целые числа
			* float числа с плавающей точкой
			* string строка/текст
				* Операции со строками
					* 1.конкатенация (объединение) строк возможна при помощи + ; 2.умножение строки на число позволит повторить ее нужное количество раз; 3. .upper() приводит строку к верхнему регистру; 4. .lower() приводит строку к нижнему регистру; 5. .capitalize() приводит первую букву к верхнему регистру; 6. .replace('что заменить', 'на что заменить') заменяет элемент в строке на указанный; 7. len(my_string) позволяет определить длину строки (количество символов в ней);
					* # преобразование строки в список (например, из CSV-файла) queries_list = queries_string.split(',')
			* boolean булевый/логический тип
		* Тип объекта можно узнать при помощи функции type().
		* Тип данных можно принудительно изменить функциями int(), float(), bool(), str()
		* Сложные
			* Списки (list) [...]
				* это структура данных для упорядоченного хранения объектов различных типов. Является изменяемым типом данных.
				* Операции со списками
					* ● списки можно складывать; ● del(list[index]) удаляет элемент из списка по индексу; ● .remove(el) удаляет указанный элемент из списка; ● .append(el) позволяет добавить элемент в список; ● .count(el) считает количество вхождений элемента в список; ● .index(el) позволяет узнать индекс элемента в списке; ● .reverse() разворачивает список; ● sorted(list) сортирует список;
					* # Преобразование списка в строку print(','.join(['Столбец 1', 'Столбец 2', 'Столбец 3']))
			* Кортежи (tuples) (...)
				* неизменяемые списки (нельзя добавлять или удалять элементы из уже созданного кортежа).
				* Занимает меньше памяти при работе с ними по сравнению со списками
				* # кортеж из одного элемента задается так: t = ('one', )
			* Множества (sets)
				* “контейнер", содержащий не повторяющиеся элементы в случайном порядке
				* Операции над множествами
					* ● .add(el) добавляет элемент в множество; ● .update(set) соединяет множество с другим множеством/списком; ● .discard(el) удаляет элемент из множества по его значению; ● .union(set) объединяет множества (логическое “ИЛИ”); ● .intersection(set) – пересечение множеств (логическое “И”); ● .difference(set) – возвращает элементы одного множества, которые не принадлежат другому множеству (разность множеств); ● .symmetric_difference(set) – возвращает элементы, которые встречаются в одном множестве, но не встречаются в обоих
			* Словари (dictionaries)
				* неупорядоченные коллекции произвольных объектов с доступом по ключу
				* Словарь инициализируется при помощи { }, элементы них хранятся в формате key:value. Ключами могут быть strings, booleans, integers и floats. Любое значение из словаря можно получить следующим образом: my_dict[key]. Все ключи в словаре должны быть уникальными.
				* Операции со словарями
					* ● del(dict[key]) удаляет элемент из списка по ключу; ● .keys() позволяет получить все ключи словаря; ● .values() позволяет получить все значения словаря; ● .items() позволяет получить ключи и значения словаря; ● .get(key) “безопасно” возвращает значение по ключу (при отсутствии ключа ошибка не возникает)
		* None
			* специальный тип данных, который означает отсутствие значения.
	* Циклы
		* while
			* Позволяет выполнить одну и ту же последовательность действий, пока проверяемое условие истинно. Как правило, цикл while используется, когда невозможно заранее определить точное значение количества проходов исполнения цикла
		* for
			* Цикл for проходится по элементам любого итерируемого объекта (строки, списка и т.д.) и во время каждого прохода выполняет заданную последовательность действий.
		* break, continue и pass
			* break прерывает исполнение цикла
			* continue завершает исполнение текущей итерации цикла и переходит к следующей итерации
			* pass игнорирует условие и продолжает исполнение цикла
	* Функции
		* Анонимные функции. Анонимные функции создаются при помощи инструкции lambda и используются для более краткой записи функций с одним выражением. Выполняются быстрее обычных и не требуют инструкции return:lambda x, pow: x**pow
		* Методы. Это функции, которые “принадлежат” к определенному объекту.
